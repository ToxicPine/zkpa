# ZKPA - Zero Knowledge Provenance Authenticity

<div align="center">

This project is for 2024 ETH Golabal London Hackathon.

</div>

<table>
  <tr>
    <td>
      <img src="./src/assets/banner.png" width="400" height="200">
    </td>
    <td>
      <img src="./src/assets/eth-london.png" width="400" height="200">
    </td>
  </tr>
</table>

## Overview

ZKPA allows manufacturers to add a signature to cameras, enabling users and third parties to verify the origin and authenticity of media, such as photos. We use cryptographic signatures to create a chain of trust which ties the image to a trusted manufacturer of trusted and secure camera hardware, then use ZK to remove the intermediate signatures whilst maintaining the security properties. In other words, it conceals the signer identities, which could potentially be used to doxx its users. It's a viable means of mitigating deepfake misinformation -- social media could flag images that lack these camera proofs, and this will prevent people from being confused, since there can be no such proofs for images that did not come from this trusted hardware.

Crucially, we implement encrypted camera identifiers, such that only trusted parties can know the true signer identities. This allows one to blacklist malicious or hacked cameras. We're working on ways of ensuring

## What, and Why?

## Core Functions

### 1. Camera Signature Creation by Manufacturers

Manufacturers add a signature to the camera to enable photo identification and tracking. This ensures that users and third parties can verify the camera's origin and the quality of the photos taken.

### 2. User Photo Capture

The camera, being trusted, allows users to capture photos.

### 3. Photo Hash Generation

Upon photo upload, the camera uses a hashing function to generate a unique hash value for the photo, ensuring its integrity and uniqueness.

### 4. Signature Generation

The camera generates a signature for the photo, proving its genuineness.

### 5. Zero-Knowledge Proof Generation

A Zero-Knowledge proof is generated to prove the photo's authenticity without revealing the actual signature. This ensures privacy and security in verifying photo authenticity.

### 6. Verification and Storage

Users can store the Zero-Knowledge proof along with the photo hash on a blockchain, enabling secure and verifiable photo authenticity.

### 7. Querying and Authenticity Verification

Other users can verify the authenticity of a photo by querying its hash. The application retrieves the corresponding Zero-Knowledge proof and photo hash, verifying the photo's authenticity without revealing its content.

## Technologies

- **Zero-Knowledge Proof (ZKP) Libraries**: Used for creating and verifying signatures without disclosing sensitive information. We used Noir.
- **Elliptic Curve Cryptography (ECC)**: Employed for securely generating and verifying Zero-Knowledge signatures.
- **Image Processing Libraries (IPL)**: Utilized for extracting data from photos, which is then used to generate ZK signatures.

## How To Test

### Web Front-End

WARNING: The frontend is almost functional, however proof verification could not be achieved due to bugs in NoirJS. We recommend inspecting the command-line utilities. It communicates with a Python Flask backend.

It runs on our Vercel, see https://zkpa.vercel.app

You can do `npm install` and `npm start` for local development.

### CLI Tools

See `circuit/scripts`. Both tools take the filename of an image, which must be stored in the same directory, as only single command-line argument.

`witnessGen.py` generates the information which one can pass to the prover to generate the proof from the circuit and prints it. Much of the code is used in our Flask backend to the web-app.

`proofGen.py` generates a proof from the stored witness information and adds the data to the EXIF of the input.

Any generated proofs can be verified with the standard Noir utilities.

**NOTE:** the proofs may fail when witness information is generated by `witnessGen.py`, since we can not generate ECDH keys on the BabyJubJub curve in Python yet. `deprecated/imageSig.py` generates valid data, but it uses hard-coded values and has not been updated according to the change in variable names.

## Limitations and Next Steps

### Limitations

1. We use AES-128 ECB in the circuit, which is slow and does not use an IV (you can tell if two ciphertexts correspond to the same plaintext).
2. We haven't implemented meta-tagging of non-image media, although this is NOT limited to images.
3. The web front-end is dysfunctional and returns a success in every case, since NoirJS is playing up. The CLI tools work better.
4. The CLI tools feature hard-coded values, because we can not generate points on ECDH with BabyJubJub on Python.
5. The tools only verify against our own certificate authority, multi-authority verification has not been implemented.

The circuit works, and the project is earnestly not far from total functionality. It's a matter of two hours of debugging and some additional tweaking.

### Next Steps

1. Using recursive proofs to allow image edits, without permitting deceptive edits, by keeping the edit history public. This will be like ZkMic.
2. Setting-up a secure authority to maintain and verify against the camera blacklist.
